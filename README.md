# Property Parser

Это библиотека для последовательного парсинга свойств в формате `ключ=значение` с помощью буфера фиксированого размера (с минимальным перераспределения памяти) и опционалдьной функцией обратного вызова для обработки найденного свойства.

## Описание

Библиотека предоставляет класс `PropertyParser` для разбора строк в формате свойств. Каждое свойство записывается в виде `ключ=значение`, где:
- `ключ` - имя свойства - неразрываня последовательность символов (регистр символов может игнорироваться) 
- `значение` - значение свойства произвольная последовательность символов
- разделителем списка может быть точка с запятой или символ перевода строки (различные форматы окончания строк: LF "\n" и CRLF "\r\n")
- пробелы, символы табуляции и комментарии игнорируются
- многострочные комментарии как в C/C++ (между слэшем и звездочкой)
- однострочные комментарии начинаются с символа решётки и продолжаются до конца строки
- если значением параметра является символьная строка, то она заключается в кавычки, а кавычки внутри символьной строки могут экранироваться обратным слэшем
- обратный слэш в конце строки перед переводом строки продолжает текущую строку
- класс парсера должен иметь статический метод поиска одного параметра по его имени, который должен возвращать истину в случае его нахождения и указатель на начало значения параметра (адрес сохраняется в возвращаемом аргументе функции)
- конструктор класса должен принимать признак регистронезависимого сравнения ключей
- ошибки парсинга не должны вызывать исключения (должны возвращать булевое значение успешности операции)
- если при парсинге входных данных отсутствует разделитель ключ-значение (знак равенства), то такая строка сохраняется в поле `propertyMatch`, которое можно получить с помощью метода `getPropertyMatch()`
- тесты должны покрывать все возможные случаи, включая неверные данные
- все описания ошибок и комментарии на английском языке

## Использование

```cpp
#include "PropertyParser.h"

// Определение callback-функции для обработки результатов парсинга
void parseCallback(void* data, const PropertyParser& parser) {
    if (parser.isValid()) {
        std::cout << "Найдено свойство: имя='" << parser.getPropertyName() 
                  << "', значение='" << parser.getPropertyValue() << "'" << std::endl;
    } else {
        std::cout << "Некорректная строка: '" << parser.getPropertyMatch() << "'" << std::endl;
    }
}

// Парсинг валидного свойства с использованием callback-функции
parser.feedAndParse("name=value;", 11, parseCallback, nullptr);

// Парсинг строки без разделителя с использованием callback-функции
parser.feedAndParse("invalid_string\n", 15, parseCallback, nullptr);

// Создание парсера с регистронезависимым сравнением
PropertyParser caseInsensitiveParser(1024, true);

// Парсинг свойства с регистронезависимым сравнением
caseInsensitiveParser.feedAndParse("Name=Value\n", 11, parseCallback, nullptr);
```

### Пример использования сопоставления по шаблону

```cpp
#include "PropertyParser.h"

// Регистрозависимое сопоставление (по умолчанию)
bool match1 = PropertyParser::matchesPattern("com.example.MyTest", "com.example.*"); // true
bool match2 = PropertyParser::matchesPattern("com.Example.MyTest", "com.example.*"); // false

// Регистронезависимое сопоставление
bool match3 = PropertyParser::matchesPattern("com.Example.MyTest", "com.example.*", false); // true
bool match4 = PropertyParser::matchesPattern("COM.EXAMPLE.MYTEST", "com.example.*", false); // true
```

## Методы класса PropertyParser

- `void feedAndParse(const char* data, size_t length, PropertyParserCallback callback = nullptr, void* callbackData = nullptr)` - Передача данных для парсинга и немедленная обработка с вызовом callback-функции
- `bool parseNext()` - Парсинг следующего токена (для внутреннего использования)
- `bool isValid() const` - Проверка валидности последнего разобранного свойства
- `const std::string& getPropertyName() const` - Получение имени свойства
- `const std::string& getPropertyValue() const` - Получение значения свойства
- `const std::string& getPropertyMatch() const` - Получение строки, не содержащей разделитель ключ-значение
- `void reset()` - Сброс состояния парсера
- `static bool matchesPattern(const std::string& str, const std::string& pattern, bool caseSensitive = true)` - Проверка соответствия строки шаблону с возможностью установки режима чувствительности к регистру

## Шаблоны

Метод `matchesPattern` позволяет проверять соответствие строки шаблону в формате, аналогичном используемому в GWT:
- `*` - соответствует любому количеству символов (включая ноль)
- `?` - соответствует ровно одному символу

Примеры:
- `"com.example.*"` - соответствует всем строкам, начинающимся с "com.example."
- `"*Test"` - соответствует всем строкам, заканчивающимся на "Test"
- `"My?est"` - соответствует строке "MyTest"

